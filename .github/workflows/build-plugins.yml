name: Build Plugins in Parallel

on:
  push:
    branches:
      - main
      - backend-builder
      - parallelize-ci
    paths:
      - "plugins/**"
      - ".github/workflows/build-plugins.yml"
  pull_request_target:
    branches: ['*']
  workflow_dispatch:
    inputs:
      upload:
        type: boolean
        description: Re-upload the plugins to the store

jobs:
  find_plugins:
    outputs:
      plugins: ${{ steps.find_plugins.outputs.plugins }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        if: ${{ !env.ACT }}
        uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - id: find_plugins
        name: Find plugins to be built
        run: |
          PLUGINS=$(find ./plugins -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -n1 -- basename | jq -Rsc 'split("\n")[:-1]')
          echo "plugins=$PLUGINS" >> $GITHUB_OUTPUT

  build:
    name: Build plugin
    runs-on: ubuntu-latest
    continue-on-error: true
    needs:
      - find_plugins
    strategy:
      matrix:
        plugin: ${{ fromJSON(needs.find_plugins.outputs.plugins) }}
    outputs:
      name: ${{ steps.set_name.outputs.name }}

    steps:
    - name: Checkout
      if: ${{ !env.ACT }}
      uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
      with:
        ref: ${{ github.event.pull_request.head.sha || github.sha }}
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout plugin submodule
      run: |
        git submodule update --init --depth 1 plugins/${{ matrix.plugin }}

    - name: Pull frontend builder image
      run: docker pull ghcr.io/steamdeckhomebrew/builder:latest

    - name: Pull backend builder image
      run: docker pull ghcr.io/steamdeckhomebrew/holo-base:latest

    - name: Build plugin backends
      run: |
        plugin=${{ matrix.plugin }}
        pushd plugins
        pushd $plugin
        echo "Detecting backend for plugin $plugin"
        dockerfile_exists="false"
        entrypoint_exists="false"
        docker_name="backend-${plugin,,}"
        # [ -d $PWD/backend ] && echo "$(ls -lla $PWD/backend | grep Dockerfile)"
        [ -f $PWD/backend/Dockerfile ] && dockerfile_exists=true
        [ -f $PWD/backend/entrypoint.sh ] && entrypoint_exists=true
        # check for Dockerfile
        if [[ "$dockerfile_exists" == "true" ]]; then
          echo "Grabbing provided dockerfile."
          echo "Building provided Dockerfile."
          docker build -f $PWD/backend/Dockerfile -t "$docker_name" .
          mkdir -p /tmp/output/$plugin/backend/out
          # check entrypoint script exists
          if [[ "$entrypoint_exists" == "true" ]]; then
            echo "Running docker image "$docker_name" with provided entrypoint script."
            docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out --entrypoint /backend/entrypoint.sh "$docker_name"
            mkdir -p /tmp/output/$plugin/bin
            cp -r /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          else
            echo "Running docker image "$docker_name" with entrypoint script specified in Dockerfile."
            docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out "$docker_name"
            mkdir -p /tmp/output/$plugin/bin
            cp -r /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          fi
          docker image rm "$docker_name"
          echo "Built $plugin backend"
        # Dockerfile doesn't exist but entrypoint script does, run w/ default image
        elif [[ "$dockerfile_exists" == "false" && "$entrypoint_exists" == "true" ]]; then
          echo "Grabbing default docker image and using provided entrypoint script."
          docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out ghcr.io/steamdeckhomebrew/holo-base:latest
          mkdir -p /tmp/output/$plugin/bin
          cp /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          echo "Built $plugin backend"
        else
          echo "Plugin $plugin does not have a backend"
        fi
        # ls -lla /tmp/output/$plugin
        popd
        popd

    - name: Build plugin frontends
      run: |
        shopt -s extglob
        pushd plugins
        plugin=${{ matrix.plugin }}
        pushd $plugin
        docker run --rm -i -v $PWD:/plugin -v /tmp/output/$plugin:/out ghcr.io/steamdeckhomebrew/builder:latest
        echo Built $plugin frontend
        ls -lla /tmp/output/$plugin
        cd /tmp/output/$plugin
        popd
        popd

    - name: Zip Plugins
      run: |
        shopt -s dotglob
        mkdir -p /tmp/zips/
        mkdir -p /tmp/output/
        redtext=$'\e[1;31m'
        end=$'\e[0m'
        pushd /tmp/output
        plugin=$(basename ${{ matrix.plugin }})
        zipname=/tmp/$plugin.zip
        echo $plugin

        # Names of the optional files (the license can either be called license or license.md, not both)
        # (head is there to take the first file, because we're assuming there's only a single license file)
        license="$(find $plugin -maxdepth 1 -type f \( -iname "license" -o -iname "license.md" \) -printf '%P\n' | head -n 1)"
        readme="$(find $plugin -maxdepth 1 -type f -iname 'readme.md' -printf '%P\n')"
        haspython="$(find $plugin -maxdepth 1 -type f -name '*.py' -printf '%P\n')"
        # Check if plugin has a bin folder, if so, add "bin" and it's contents to root dir
        hasbin="$(find $plugin -maxdepth 1 -type d -name 'bin' -printf '%P\n')"
        # Check if plugin has a defaults folder, if so, add "default" contents to root dir
        hasdefaults="$(find $plugin -maxdepth 1 -type d -name 'defaults' -printf '%P\n')"
        if [[ "${{ secrets.STORE_ENV }}" == "testing" ]]; then
          long_sha="${{ github.event.pull_request.head.sha || github.sha }}"
          sha=$(echo $long_sha | cut -c1-7)
          cat $plugin/package.json | jq --arg jqsha "$sha" '.version |= . + "-" + $jqsha' | sudo tee $plugin/$sha-package.json
          sudo mv $plugin/$sha-package.json $plugin/package.json
        fi
        # Add required plugin files (and directory) to zip file
        echo "$plugin/dist $plugin/plugin.json $plugin/package.json"
        zip -r $zipname "$plugin/dist" "$plugin/plugin.json" "$plugin/package.json"
        if [ ! -z "$hasbin" ]; then
          echo "$plugin/bin"
          zip -r $zipname "$plugin/bin"
        fi

        if [ ! -z "$haspython" ]; then
          echo "$plugin/*.py"
          find $plugin -maxdepth 1 -type f -name '*.py' -exec zip -r $zipname {} \;
        fi

        if [ ! -z "$hasdefaults" ]; then
          export workingdir=$PWD
          cd $plugin/defaults
          export plugin="$plugin"
          export zipname="$zipname"
          if [ ! -f "defaults.txt" ]; then
            find . -mindepth 1 -type d,f -name '*' -exec bash -c '
              for object do
                outdir="/tmp/output"
                name="$(basename $object)"
                # echo "object = $object, name = $name"
                if [ -e "$object" ]; then
                  sudo mv "$object" $outdir/$plugin/$name
                  moved="$?"
                  # echo "moved = $moved"
                  cd $workingdir
                  if [ "$moved" = "0" ]; then
                    zip -r $zipname $plugin/$name
                  fi
                fi
              done
            ' find-sh {} + ;
          else
            if [[ ! "$plugin" =~ "plugin-template" ]]; then
              printf "${red}defaults.txt found in defaults folder, please remove either defaults.txt or the defaults folder.${end}\n"
            else
              printf "plugin template, allowing defaults.txt\n"
            fi
          fi
          cd "$workingdir"
        fi

        # Check if other files exist, and if they do, add them
        echo "license:$plugin/$license readme:$plugin/$readme"
        if [ ! -z "$license" ]; then
          zip -r $zipname "$plugin/$license"
        fi
        if [ ! -z "$readme" ]; then
          zip -r $zipname "$plugin/$readme"
        fi
        popd

    - name: Upload plugin artifact
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.plugin }}
        path: /tmp/${{ matrix.plugin }}.zip

  get_env_secrets:
    runs-on: ubuntu-latest
    continue-on-error: true
    needs:
      - find_plugins
    environment:
      name: ${{ (github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.upload))) && 'env' || 'testing_env' }}
    steps:
    - id: get_env_secrets
      name: Get environment secrets
      run: |
        echo "${JSON}"
        echo "env=${JSON}" >> $GITHUB_OUTPUT
      env:
        JSON: ${{ toJSON(secrets) }}

  upload:
    runs-on: ubuntu-latest
    continue-on-error: true
    needs:
      - find_plugins
      - get_env_secrets
    env: ${{ fromJSON(needs.get_env_secrets.outputs.env) }}
    strategy:
      matrix:
        plugin: ${{ fromJSON(needs.find_plugins.outputs.plugins) }}
    steps:
    - name: Wait for build to finish
      id: check-status
      uses: fountainhead/action-wait-for-check@v1.1.0
      with:
        ref: ${{ github.event.pull_request.head.sha || github.sha }}
        checkName: 'Build plugin (${{ matrix.plugin }})'
        token: ${{ secrets.GITHUB_TOKEN }}
        timeoutSeconds: 21600
        intervalSeconds: 10

    - name: Exit if build failed
      if: steps.check-status.outputs.conclusion != 'success'
      run: echo "Build failed." && exit 1

    - name: Upload
      run: |
        echo "Uploading ${{ matrix.plugin }} (but not really)"
